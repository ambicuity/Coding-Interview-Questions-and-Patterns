# Coding Interview Questions and Patterns

**Author:** Ritesh Rana

## Overview

Welcome to the most comprehensive coding interview preparation repository! This collection contains detailed explanations, working code examples, and interview tips for all major coding interview patterns. Whether you're a college student just starting your coding journey or an experienced professional looking to brush up on algorithms, this repository provides in-depth coverage of essential topics.

## What Makes This Repository Special

### üéØ **Comprehensive Coverage**
19 major algorithmic patterns covering 100+ coding problems from basic to advanced level, ensuring complete interview preparation coverage.

### üìö **Multiple Skill Levels** 
Detailed explanations and examples suitable for:
- **Beginners**: Clear fundamental explanations with step-by-step examples
- **Intermediate**: Optimization techniques and advanced use cases
- **Advanced**: Complex variations and cutting-edge optimizations

### üíª **Production-Ready Code**
All examples are:
- Thoroughly tested with multiple test cases
- Ready to download, run, and modify
- Optimized for both time and space complexity
- Documented with clear comments and explanations

### üé™ **Interview-Focused Content**
- Real interview questions from top tech companies (FAANG+)
- Strategic insights and tips from experienced interviewers
- Common follow-up questions and variations
- Time management and problem-solving strategies

### üîÑ **Multiple Solution Approaches**
Each problem includes:
- Brute force approach for understanding
- Optimized solutions with detailed complexity analysis
- Alternative methods and trade-offs discussion
- Space optimization techniques when applicable

### üåê **Multi-Language Support**
Complete implementations in:
- **Python**: Clean, readable syntax ideal for interviews
- **Java**: Enterprise-grade implementations with proper OOP
- **JavaScript**: Modern ES6+ syntax for web developers

### üìä **Detailed Analysis**
Every solution includes:
- **Time Complexity**: Big O analysis with detailed explanation
- **Space Complexity**: Memory usage breakdown
- **Edge Cases**: Comprehensive edge case handling
- **Optimization Notes**: Further improvement possibilities

### üéì **Learning Path Integration**
- Structured progression from basic to advanced concepts
- Cross-pattern relationships and dependencies
- Prerequisite tracking and skill building
- Progress checkpoints and milestones

## Topics Covered

### 01. Two Pointers
- Introduction to Two Pointers
- Pair Sum - Sorted
- Triplet Sum
- Is Palindrome Valid
- Largest Container
- Shift Zeros to the End
- Next Lexicographical Sequence

### 02. Hash Maps and Sets
- Introduction to Hash Maps and Sets
- Pair Sum - Unsorted
- Verify Sudoku Board
- Zero Striping
- Longest Chain of Consecutive Numbers
- Geometric Sequence Triplets

### 03. Linked Lists
- Introduction to Linked Lists
- Linked List Reversal
- Remove the Kth Last Node From a Linked List
- Linked List Intersection
- LRU Cache
- Palindromic Linked List
- Flatten a Multi-Level Linked List

### 04. Fast and Slow Pointers
- Introduction to Fast and Slow Pointers
- Linked List Loop
- Linked List Midpoint
- Happy Number

### 05. Sliding Windows
- Introduction to Sliding Windows
- Substring Anagrams
- Longest Substring With Unique Characters
- Longest Uniform Substring After Replacements

### 06. Binary Search
- Introduction to Binary Search
- Find the Insertion Index
- First and Last Occurrences of a Number
- Cutting Wood
- Find the Target in a Rotated Sorted Array
- Find the Median From Two Sorted Arrays
- Matrix Search
- Local Maxima in Array
- Weighted Random Selection

### 07. Stacks
- Introduction to Stacks
- Valid Parenthesis Expression
- Next Largest Number to the Right
- Evaluate Expression
- Repeated Removal of Adjacent Duplicates
- Implement a Queue using Stacks
- Maximums of Sliding Window

### 08. Heaps
- Introduction to Heaps
- K Most Frequent Strings
- Combine Sorted Linked Lists
- Median of an Integer Stream
- Sort a K-Sorted Array

### 09. Intervals
- Introduction to Intervals
- Merge Overlapping Intervals
- Identify All Interval Overlaps
- Largest Overlap of Intervals

### 10. Prefix Sums
- Introduction to Prefix Sums
- Sum Between Range
- K-Sum Subarrays
- Product Array Without Current Element

### 11. Trees
- Introduction to Trees
- Invert Binary Tree
- Balanced Binary Tree Validation
- Rightmost Nodes of a Binary Tree
- Widest Binary Tree Level
- Binary Search Tree Validation
- Lowest Common Ancestor
- Build Binary Tree From Preorder and Inorder Traversals
- Maximum Sum of a Continuous Path in a Binary Tree
- Binary Tree Symmetry
- Binary Tree Columns
- Kth Smallest Number in a Binary Search Tree
- Serialize and Deserialize a Binary Tree

### 12. Tries
- Introduction to Tries
- Design a Trie
- Insert and Search Words with Wildcards
- Find All Words on a Board

### 13. Graphs
- Introduction to Graphs
- Graph Deep Copy
- Count Islands
- Matrix Infection
- Bipartite Graph Validation
- Longest Increasing Path
- Shortest Transformation Sequence
- Merging Communities
- Prerequisites
- Shortest Path
- Connect the Dots

### 14. Backtracking
- Introduction to Backtracking
- Find All Permutations
- Find All Subsets
- N Queens
- Combinations of a Sum
- Phone Keypad Combinations

### 15. Dynamic Programming
- Introduction to Dynamic Programming
- Climbing Stairs
- Minimum Coin Combination
- Matrix Pathways
- Neighborhood Burglary
- Longest Common Subsequence
- Longest Palindrome in a String
- Maximum Subarray Sum
- 0/1 Knapsack
- Largest Square in a Matrix

### 16. Greedy
- Introduction to Greedy Algorithms
- Jump to the End
- Gas Stations
- Candies

### 17. Sort and Search
- Introduction to Sort and Search
- Sort Linked List
- Sort Array
- Kth Largest Integer
- Dutch National Flag

### 18. Bit Manipulation
- Introduction to Bit Manipulation
- Hamming Weights of Integers
- Lonely Integer
- Swap Odd and Even Bits

### 19. Math and Geometry
- Introduction to Math and Geometry
- Spiral Traversal
- Reverse 32-Bit Integer
- Maximum Collinear Points
- The Josephus Problem
- Triangle Numbers

## Pattern Difficulty and Complexity Guide

### üìä Time Complexity Summary by Pattern

| Pattern | Typical Time | Typical Space | Common Applications |
|---------|--------------|---------------|-------------------|
| Two Pointers | O(n) | O(1) | Array/String problems |
| Hash Maps | O(n) | O(n) | Fast lookups, counting |
| Linked Lists | O(n) | O(1) | Dynamic data structures |
| Fast/Slow Pointers | O(n) | O(1) | Cycle detection |
| Sliding Window | O(n) | O(k) | Subarray problems |
| Binary Search | O(log n) | O(1) | Sorted array search |
| Stacks | O(n) | O(n) | Expression parsing |
| Heaps | O(n log n) | O(n) | Priority queues |
| Intervals | O(n log n) | O(n) | Scheduling problems |
| Prefix Sums | O(n) | O(n) | Range queries |
| Trees | O(n) | O(h) | Hierarchical data |
| Tries | O(m) | O(ALPHABET √ó N √ó M) | String searching |
| Graphs | O(V + E) | O(V) | Relationship problems |
| Backtracking | O(b^d) | O(d) | Combinatorial problems |
| Dynamic Programming | O(n¬≤) or O(n¬≥) | O(n) or O(n¬≤) | Optimization problems |
| Greedy | O(n log n) | O(1) | Local optimization |
| Sort and Search | O(n log n) | O(n) | Ordering problems |
| Bit Manipulation | O(1) to O(n) | O(1) | Low-level operations |
| Math & Geometry | O(n) to O(n¬≤) | O(1) to O(n) | Mathematical problems |

### üìà Learning Difficulty Progression

**üü¢ Beginner-Friendly (Weeks 1-2):**
1. **Two Pointers** - Simple array traversal patterns
2. **Hash Maps and Sets** - Basic lookups and counting
3. **Linked Lists** - Fundamental pointer manipulation
4. **Stacks** - LIFO operations and basic applications

**üü° Intermediate Level (Weeks 3-5):**
5. **Fast and Slow Pointers** - Advanced pointer techniques
6. **Sliding Window** - Optimized subarray problems
7. **Binary Search** - Efficient searching in sorted data
8. **Heaps** - Priority-based data structures
9. **Intervals** - Time-based problem solving
10. **Prefix Sums** - Cumulative array operations

**üü† Advanced Beginner (Weeks 6-8):**
11. **Trees** - Hierarchical data structure mastery
12. **Tries** - Specialized string data structures
13. **Sort and Search** - Algorithm optimization
14. **Bit Manipulation** - Low-level programming concepts

**üî¥ Advanced Level (Weeks 9-12):**
15. **Graphs** - Complex relationship modeling
16. **Backtracking** - Exhaustive solution exploration
17. **Dynamic Programming** - Complex optimization problems
18. **Greedy Algorithms** - Strategic decision making
19. **Math and Geometry** - Mathematical problem solving

### üéØ Interview Frequency by Pattern

**Most Common (Asked in 80%+ interviews):**
- Array and String manipulation (Two Pointers, Sliding Window)
- Hash Maps for lookups and counting
- Tree traversal and basic operations
- Linked List manipulation
- Basic sorting and searching

**Common (Asked in 50-80% interviews):**
- Dynamic Programming (easier problems)
- Graphs (BFS/DFS, basic algorithms)
- Heaps for top-K problems
- Binary Search variants
- Stacks for parsing problems

**Moderate (Asked in 20-50% interviews):**
- Advanced Tree problems
- Backtracking for combinations/permutations
- Interval problems
- Trie-based string problems
- Prefix sums for range queries

**Less Common (Asked in 5-20% interviews):**
- Advanced Dynamic Programming
- Complex Graph algorithms
- Bit manipulation tricks
- Advanced Math and Geometry
- Greedy algorithm proofs

### üöÄ Company-Specific Pattern Preferences

**FAANG Companies:**
- **Google**: Trees, Graphs, Dynamic Programming, Math
- **Amazon**: Arrays, Strings, Trees, Design (Heaps/Stacks)
- **Apple**: Trees, Arrays, Dynamic Programming, System Design
- **Netflix**: Arrays, Strings, Hash Maps, Optimization
- **Facebook/Meta**: Graphs, Trees, Dynamic Programming, Hash Maps

**Other Top Tech:**
- **Microsoft**: Trees, Dynamic Programming, Arrays, Recursion
- **Adobe**: Arrays, Strings, Trees, Hash Maps
- **Salesforce**: Arrays, Hash Maps, Trees, Basic Algorithms
- **Uber/Lyft**: Graphs, Heaps, Hash Maps, Optimization
- **Twitter**: Hash Maps, Trees, Strings, Scaling Problems

## How to Use This Repository

### For Beginners
1. **Start with Fundamentals**: Begin with Two Pointers and Hash Maps patterns
2. **Follow the Learning Path**: Progress through patterns in numerical order
3. **Practice Regularly**: Solve at least 2-3 problems daily
4. **Focus on Understanding**: Don't just memorize solutions, understand the patterns

### For Intermediate Developers
1. **Target Weak Areas**: Use the repository to strengthen specific algorithmic skills
2. **Time Yourself**: Practice problems under interview conditions (45-60 minutes)
3. **Implement in Multiple Languages**: Try solutions in Python, Java, and JavaScript
4. **Study Optimizations**: Focus on advanced techniques and space/time optimizations

### For Advanced Practitioners
1. **Focus on Hard Problems**: Concentrate on Dynamic Programming, Graphs, and Advanced Trees
2. **Teach Others**: Use the explanations to mentor junior developers
3. **Contribute**: Share your optimizations and alternative approaches
4. **Interview Preparation**: Use as a comprehensive review before technical interviews

### Study Schedule Recommendations

**4-Week Intensive Plan:**
- Week 1: Two Pointers, Hash Maps, Linked Lists, Fast & Slow Pointers
- Week 2: Sliding Windows, Binary Search, Stacks, Heaps
- Week 3: Intervals, Prefix Sums, Trees, Tries
- Week 4: Graphs, Backtracking, Dynamic Programming

**8-Week Comprehensive Plan:**
- Weeks 1-2: Master basic patterns (Two Pointers through Binary Search)
- Weeks 3-4: Learn intermediate patterns (Stacks through Trees)
- Weeks 5-6: Advanced patterns (Tries through Dynamic Programming)  
- Weeks 7-8: Complex patterns (Greedy through Math & Geometry) + Review

### Setting Up Your Environment

**Prerequisites:**
- Basic programming knowledge in at least one language
- Understanding of basic data structures (arrays, strings, basic math)
- Code editor or IDE of your choice

**Recommended Tools:**
- **Python**: PyCharm, VS Code, or Jupyter Notebooks
- **Java**: IntelliJ IDEA, Eclipse, or VS Code with Java extensions
- **JavaScript**: VS Code, WebStorm, or browser console for quick testing

**Testing Your Solutions:**
```bash
# For Python examples
cd pattern-directory/code/python
python3 problem_name.py

# For Java examples  
cd pattern-directory/code/java
javac ProblemName.java
java ProblemName

# For JavaScript examples
cd pattern-directory/code/javascript
node problem_name.js
```

### Pattern Relationships and Dependencies

**Foundation Patterns** (Start Here):
- Hash Maps and Sets ‚Üí Used in many other patterns
- Two Pointers ‚Üí Foundation for many array problems

**Building Block Patterns**:
- Linked Lists ‚Üí Required for Trees and Graphs
- Binary Search ‚Üí Used in many optimization problems
- Stacks ‚Üí Foundation for tree traversals and expression parsing

**Intermediate Patterns**:
- Sliding Windows ‚Üí Builds on Two Pointers
- Trees ‚Üí Foundation for advanced tree problems and graphs
- Heaps ‚Üí Used in graph algorithms and optimization

**Advanced Patterns**:
- Dynamic Programming ‚Üí Uses concepts from multiple patterns
- Graphs ‚Üí Combines trees, BFS, DFS, and other techniques
- Backtracking ‚Üí Advanced recursion building on tree concepts

### Progress Tracking

Track your progress with this checklist:

**Basic Level** (Can solve Easy problems):
- [ ] Two Pointers
- [ ] Hash Maps and Sets  
- [ ] Linked Lists
- [ ] Binary Search (basic)
- [ ] Stacks (basic)

**Intermediate Level** (Can solve Medium problems):
- [ ] Fast and Slow Pointers
- [ ] Sliding Windows
- [ ] Binary Search (advanced)
- [ ] Heaps
- [ ] Trees (basic)
- [ ] Intervals

**Advanced Level** (Can solve Hard problems):
- [ ] Trees (advanced)
- [ ] Graphs
- [ ] Dynamic Programming
- [ ] Backtracking
- [ ] Advanced patterns (Tries, Greedy, etc.)

### Performance Benchmarks

**Target Solving Times (Per Problem):**
- Easy: 15-25 minutes
- Medium: 25-45 minutes  
- Hard: 45-75 minutes

**Code Quality Checklist:**
- [ ] Handles edge cases
- [ ] Optimal time complexity
- [ ] Reasonable space complexity
- [ ] Clean, readable code
- [ ] Proper variable naming
- [ ] Comments for complex logic

## Contributing

This repository is authored and maintained by Ritesh Rana. Contributions are welcome!

### How to Contribute
1. **Report Issues**: Found a bug or typo? Open an issue
2. **Suggest Improvements**: Have ideas for better explanations or optimizations?
3. **Add Test Cases**: Help expand the test coverage
4. **Language Support**: Add implementations in additional programming languages
5. **Alternative Solutions**: Share different approaches to existing problems

### Contribution Guidelines
- Follow the existing code style and documentation format
- Add comprehensive comments and explanations
- Include time and space complexity analysis
- Add test cases for new implementations
- Update README files when adding new content

## Interview Tips and Best Practices

### Before the Interview
- Review fundamental concepts for each pattern
- Practice coding without IDE assistance
- Prepare to explain your thought process clearly
- Study common follow-up questions

### During the Interview  
- Ask clarifying questions about requirements and constraints
- Start with brute force, then optimize
- Think out loud and explain your approach
- Test your solution with examples
- Discuss trade-offs between different approaches

### Common Interview Mistakes to Avoid
- Jumping to code without understanding the problem
- Not considering edge cases
- Focusing only on time complexity, ignoring space complexity
- Not testing the solution thoroughly
- Being unable to explain the algorithm clearly

## License

This repository is created for educational purposes. All content is authored by Ritesh Rana.

### Usage Rights
- ‚úÖ Personal study and practice
- ‚úÖ Educational use in classrooms
- ‚úÖ Reference during interviews (mention the source)
- ‚úÖ Sharing with friends and colleagues
- ‚ùå Commercial redistribution without permission
- ‚ùå Claiming authorship of the content

---
*Happy Coding and Good Luck with Your Interviews!*
